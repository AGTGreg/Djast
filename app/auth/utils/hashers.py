"""
Minimal async password hashing utility compatible with Django.
This file is based on:
https://github.com/django/django/blob/stable/6.0.x/django/contrib/auth/hashers.py

Supports only pbkdf2_sha256 (Django's default) and pbkdf2_sha1 (legacy).
"""
from __future__ import annotations

import base64
import functools
import hashlib
import importlib
import math
import warnings
import asyncio
from typing import Any, Callable

from auth.utils.crypto import (
    RANDOM_STRING_CHARS,
    constant_time_compare,
    get_random_string,
    pbkdf2,
)
from auth.utils.encoding import force_str


UNUSABLE_PASSWORD_PREFIX = "!"  # This will never be a valid encoded hash
UNUSABLE_PASSWORD_SUFFIX_LENGTH = (
    40  # number of random chars to add after UNUSABLE_PASSWORD_PREFIX
)

# Available hashers mapped by name
HASHERS: dict[str, type[BasePasswordHasher]] = {}  # Populated after class definitions
DEFAULT_HASHER = "pbkdf2_sha256"


def _get_default_hasher_name() -> str:
    """Get the default hasher name from settings or use default."""
    try:
        from djast.settings import settings
        return getattr(settings, "PASSWORD_HASHER", DEFAULT_HASHER)
    except ImportError:
        return DEFAULT_HASHER


def is_password_usable(encoded: str | None) -> bool:
    """
    Return True if this password wasn't generated by
    User.set_unusable_password(), i.e. make_password(None).
    """
    return encoded is None or not encoded.startswith(UNUSABLE_PASSWORD_PREFIX)


def verify_password(password: str | None, encoded: str, preferred: str = "default") -> tuple[bool, bool]:
    """
    Return two booleans. The first is whether the raw password matches the
    three part encoded digest, and the second whether to regenerate the
    password.
    """
    fake_runtime = password is None or not is_password_usable(encoded)

    preferred_hasher = get_hasher(preferred)
    try:
        hasher = identify_hasher(encoded)
    except ValueError:
        # encoded is gibberish or uses a hasher that's no longer installed.
        fake_runtime = True

    if fake_runtime:
        # Run the default password hasher once to reduce the timing difference
        # between an existing user with an unusable password and a nonexistent
        # user or missing hasher (similar to #20760 (Django)).
        _make_password(get_random_string(UNUSABLE_PASSWORD_SUFFIX_LENGTH))
        return False, False

    hasher_changed = hasher.algorithm != preferred_hasher.algorithm
    must_update = hasher_changed or preferred_hasher.must_update(encoded)
    is_correct = hasher.verify(password, encoded)

    # If the hasher didn't change (we don't protect against enumeration if it
    # does) and the password should get updated, try to close the timing gap
    # between the work factor of the current encoded password and the default
    # work factor.
    if not is_correct and not hasher_changed and must_update:
        hasher.harden_runtime(password, encoded)

    return is_correct, must_update


async def check_password(password: str, encoded: str, setter: Callable[[str], Any] | None = None, preferred: str = "default") -> bool:
    """
    Async version of check_password().

    Return a boolean of whether the raw password matches the three part encoded
    digest.

    If setter is specified, it'll be called when you need to regenerate the
    password.
    """
    is_correct, must_update = await asyncio.to_thread(
        verify_password, password, encoded, preferred
    )
    if setter and is_correct and must_update:
        if asyncio.iscoroutinefunction(setter):
            await setter(password)
        else:
            await asyncio.to_thread(setter, password)
    return is_correct


def _make_password(password: str | None, salt: str | None = None, hasher: str = "default") -> str:
    """
    Turn a plain-text password into a hash for database storage

    Same as encode() but generate a new random salt. If password is None then
    return a concatenation of UNUSABLE_PASSWORD_PREFIX and a random string,
    which disallows logins. Additional random string reduces chances of gaining
    access to staff or superuser accounts. See ticket #20079 (Django) for more info.
    """
    if password is None:
        return UNUSABLE_PASSWORD_PREFIX + get_random_string(
            UNUSABLE_PASSWORD_SUFFIX_LENGTH
        )
    if not isinstance(password, (bytes, str)):
        raise TypeError(
            f"Password must be a string or bytes, got {type(password).__qualname__}."
        )
    hasher_instance = get_hasher(hasher)
    salt = salt or hasher_instance.salt()
    return hasher_instance.encode(password, salt)


async def make_password(password: str | None, salt: str | None = None, hasher: str = "default") -> str:
    """
    Async version of make_password().

    Turn a plain-text password into a hash for database storage.
    """
    return await asyncio.to_thread(_make_password, password, salt, hasher)


@functools.lru_cache(maxsize=16)
def _get_hasher_by_name(algorithm: str) -> BasePasswordHasher:
    """Cache hasher instances by explicit algorithm name."""
    try:
        return HASHERS[algorithm]()
    except KeyError:
        raise ValueError(
            f"Unknown algorithm '{algorithm}'. "
            f"Available algorithms: {', '.join(HASHERS.keys())}"
        )


def get_hasher(algorithm: str | BasePasswordHasher = "default") -> BasePasswordHasher:
    """
    Return an instance of a loaded password hasher.

    If algorithm is 'default', return the default hasher from settings.
    Available hashers: 'pbkdf2_sha256', 'pbkdf2_sha1'
    """
    if hasattr(algorithm, "algorithm"):
        return algorithm
    if algorithm == "default":
        algorithm = _get_default_hasher_name()
    return _get_hasher_by_name(algorithm)


def identify_hasher(encoded: str) -> BasePasswordHasher:
    """
    Return an instance of a loaded password hasher.

    Identify hasher algorithm by examining encoded hash, and call
    get_hasher() to return hasher. Raise ValueError if
    algorithm cannot be identified, or if hasher is not loaded.
    """
    # Ancient versions of Django created plain MD5 passwords and accepted
    # MD5 passwords with an empty salt.
    if (len(encoded) == 32 and "$" not in encoded) or (
        len(encoded) == 37 and encoded.startswith("md5$$")
    ):
        algorithm = "unsalted_md5"
    # Ancient versions of Django accepted SHA1 passwords with an empty salt.
    elif len(encoded) == 46 and encoded.startswith("sha1$$"):
        algorithm = "unsalted_sha1"
    else:
        algorithm = encoded.split("$", 1)[0]
    return get_hasher(algorithm)


def mask_hash(hash: str, show: int = 6, char: str = "*") -> str:
    """
    Return the given hash, with only the first ``show`` number shown. The
    rest are masked with ``char`` for security reasons.
    """
    masked = hash[:show]
    masked += char * len(hash[show:])
    return masked


def must_update_salt(salt: str, expected_entropy: int) -> bool:
    # Each character in the salt provides log_2(len(alphabet)) bits of entropy.
    return len(salt) * math.log2(len(RANDOM_STRING_CHARS)) < expected_entropy


class BasePasswordHasher:
    """
    Abstract base class for password hashers

    When creating your own hasher, you need to override algorithm,
    verify(), encode() and safe_summary().

    PasswordHasher objects are immutable.
    """

    algorithm: str | None = None
    library: str | tuple[str, str] | None = None
    salt_entropy: int = 128

    def _load_library(self) -> Any:
        if self.library is not None:
            if isinstance(self.library, (tuple, list)):
                name, mod_path = self.library
            else:
                mod_path = self.library
            try:
                module = importlib.import_module(mod_path)
            except ImportError as e:
                raise ValueError(
                    f"Couldn't load {self.__class__.__name__} algorithm library: {e}"
                )
            return module
        raise ValueError(
            "Hasher %r doesn't specify a library attribute" % self.__class__.__name__
        )

    def salt(self) -> str:
        """
        Generate a cryptographically secure nonce salt in ASCII with an entropy
        of at least `salt_entropy` bits.
        """
        # Each character in the salt provides
        # log_2(len(alphabet)) bits of entropy.
        char_count = math.ceil(self.salt_entropy / math.log2(len(RANDOM_STRING_CHARS)))
        return get_random_string(char_count, allowed_chars=RANDOM_STRING_CHARS)

    def verify(self, password: str, encoded: str) -> bool:
        """Check if the given password is correct."""
        raise NotImplementedError(
            "subclasses of BasePasswordHasher must provide a verify() method"
        )

    def _check_encode_args(self, password: str | None, salt: str) -> None:
        if password is None:
            raise TypeError("password must be provided.")
        if not salt or "$" in force_str(salt):  # salt can be str or bytes.
            raise ValueError("salt must be provided and cannot contain $.")

    def encode(self, password: str, salt: str) -> str:
        """
        Create an encoded database value.

        The result is normally formatted as "algorithm$salt$hash" and
        must be fewer than 128 characters.
        """
        raise NotImplementedError(
            "subclasses of BasePasswordHasher must provide an encode() method"
        )

    def decode(self, encoded: str) -> dict[str, Any]:
        """
        Return a decoded database value.

        The result is a dictionary and should contain `algorithm`, `hash`, and
        `salt`. Extra keys can be algorithm specific like `iterations` or
        `work_factor`.
        """
        raise NotImplementedError(
            "subclasses of BasePasswordHasher must provide a decode() method."
        )

    def safe_summary(self, encoded: str) -> dict[str, Any]:
        """
        Return a summary of safe values.

        The result is a dictionary and will be used where the password field
        must be displayed to construct a safe representation of the password.
        """
        raise NotImplementedError(
            "subclasses of BasePasswordHasher must provide a safe_summary() method"
        )

    def must_update(self, encoded: str) -> bool:
        return False

    def harden_runtime(self, password: str, encoded: str) -> None:
        """
        Bridge the runtime gap between the work factor supplied in `encoded`
        and the work factor suggested by this hasher.

        Taking PBKDF2 as an example, if `encoded` contains 20000 iterations and
        `self.iterations` is 30000, this method should run password through
        another 10000 iterations of PBKDF2. Similar approaches should exist
        for any hasher that has a work factor. If not, this method should be
        defined as a no-op to silence the warning.
        """
        warnings.warn(
            "subclasses of BasePasswordHasher should provide a harden_runtime() method"
        )


class PBKDF2PasswordHasher(BasePasswordHasher):
    """
    Secure password hashing using the PBKDF2 algorithm (recommended)

    Configured to use PBKDF2 + HMAC + SHA256.
    The result is a 64 byte binary string. Iterations may be changed
    safely but you must rename the algorithm if you change SHA256.
    """

    algorithm: str = "pbkdf2_sha256"
    iterations: int = 1_200_000
    digest: Any = hashlib.sha256

    def encode(self, password: str, salt: str, iterations: int | None = None) -> str:
        self._check_encode_args(password, salt)
        iterations = iterations or self.iterations
        password = force_str(password)
        salt = force_str(salt)
        hash = pbkdf2(password, salt, iterations, digest=self.digest)
        hash = base64.b64encode(hash).decode("ascii").strip()
        return "%s$%d$%s$%s" % (self.algorithm, iterations, salt, hash)

    def decode(self, encoded: str) -> dict[str, Any]:
        algorithm, iterations, salt, hash = encoded.split("$", 3)
        if algorithm != self.algorithm:
            raise ValueError(
                f"Algorithm mismatch: expected {self.algorithm}, got {algorithm}"
            )
        return {
            "algorithm": algorithm,
            "hash": hash,
            "iterations": int(iterations),
            "salt": salt,
        }

    def verify(self, password: str, encoded: str) -> bool:
        decoded = self.decode(encoded)
        encoded_2 = self.encode(password, decoded["salt"], decoded["iterations"])
        return constant_time_compare(encoded, encoded_2)

    def safe_summary(self, encoded: str) -> dict[str, Any]:
        decoded = self.decode(encoded)
        return {
            "algorithm": decoded["algorithm"],
            "iterations": decoded["iterations"],
            "salt": mask_hash(decoded["salt"]),
            "hash": mask_hash(decoded["hash"]),
        }

    def must_update(self, encoded: str) -> bool:
        decoded = self.decode(encoded)
        update_salt = must_update_salt(decoded["salt"], self.salt_entropy)
        return (decoded["iterations"] != self.iterations) or update_salt

    def harden_runtime(self, password: str, encoded: str) -> None:
        decoded = self.decode(encoded)
        extra_iterations = self.iterations - decoded["iterations"]
        if extra_iterations > 0:
            self.encode(password, decoded["salt"], extra_iterations)


class PBKDF2SHA1PasswordHasher(PBKDF2PasswordHasher):
    """
    Alternate PBKDF2 hasher which uses SHA1, the default PRF
    recommended by PKCS #5. This is compatible with other
    implementations of PBKDF2, such as openssl's
    PKCS5_PBKDF2_HMAC_SHA1().
    """

    algorithm = "pbkdf2_sha1"
    digest = hashlib.sha1


# Register available hashers
HASHERS.update({
    "pbkdf2_sha256": PBKDF2PasswordHasher,
    "pbkdf2_sha1": PBKDF2SHA1PasswordHasher
})
